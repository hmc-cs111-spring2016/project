### Comments on your Development Environment

In class and in your notebook you describe a potential data-interpretation model.  In this model, users enter a list of functions they want to use on a specific sound file and then run the program.  The output would be the sound file after all the functions have been run on it.  
The main issue I see with this is that users won't be able to hear what the sound file sounds like between each function call.  This kind of immediate feedback is crucial for doing any sort of complex, multi-step alterations to sound.  
Let's say, for example, that I'm trying to turn a snapping sound, "snap.wav" into a punching sound.  To accomplish this I might need to lower the pitch, stretch out the sound file, and add saturation, reverb, and delay/echo.  Even if I might be able to pinpoint exactly which functions I'll need to use, there's no way I could tell what order would be best to call them in (and changing the order of calls will drastically change the final output).  
For this reason, I'd go with the REPL interface.  This would allow users to hear what the sound file sounds like at each step, and either go from there or undo the last function they called and start over.  I'm guessing that using the console would probably be fine for the purposes of this project.

### Other comments

- It's good that you found a library (pydub) that does most of what you need in the backend.  However, I still wouldn't put off integrating it into your project.  
- From our discussion of internal data/logic (reminder): In addition to storing the current sound file the user is working on, you'll also probably want to store previous versions so that users can "undo" their commands.  This should scale to having multiple sound files in the user's "workspace."  Also, I like the idea you brought up of having functions be their own objects - this would allow for features like setting default parameters for functions.
- Also: we were discussing PEG.js and parser vs parser generator in class.  Keep in mind that pyparser is also a parser generator.  From what I've [seen](http://stackoverflow.com/questions/1776185/advice-on-python-parser-generators), it looks pretty straightforward to use as well.  If I were you, I'd lay out the basic architecture (from input -> parsing -> internal data -> logic -> output) as soon as possible.  Just choose a single function to start with, and create a horizontal slice of your DSL to support it.  That should give you a better sense of the project as a whole (it did for me, which is why I'm recommending it).
