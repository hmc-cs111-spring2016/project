# py-DJ
## Introduction

Given how popular electronic music has become, several fans probably have a few of their own novel ideas, but no outlet for them. Most existing [audio](https://www.ableton.com/en/shop/) [mixing](https://itunes.apple.com/us/app/logic-pro-x/id634148309?mt=12) software is not only very pricey, but also extremely complicated. Even open-sourced [alternatives](http://www.audacityteam.org/) that are significantly cheaper remain are no easier to use than their expensive counterparts. It is important to note that these existing pieces of software are extremely powerful. However, as a result, they have also become increasingly unintuitive and genuinely intimidating for first-time users. Simply learning how to perform the most basic of tasks such as adjusting volume or splitting files can take anywhere from 25 minutes to as long as 2 hours. 

This language hopes to help amateurs who simply want some exposure to audio mixing without the time or capital investments. Most audio mixing softwares aim to emulate all the functionality associated with a DJ console, including allowing for most effect units and raw manipulation of the sound files. To facilitate this emulation, most audio editing software has developed a GUI, which, to most, seems like a natural decision. A GUI provides visualization of abstract concepts, responsiveness, and, in theory, ease of use. However, to me, I believe there is a fine line separating the complexity of features and ease of use that has long since been crossed. Although a GUI still provides visualization and responsiveness, I would argue that the user interface could be more effectively designed to accommodate both amateur and professional audio editors. In particular, I felt audio mixing could be more effectively done through a well-designed language and an entirely text-based interface. Although an unconventional approach, through effective language design, a text-based interface could provide responsiveness and a sense of "visualization" while maintaining the "easy to learn" aspect made possible because of the simple interface. The idea is to make the learning curve necessary to edit music significantly less intimidating.

### Currently
py-DJ is a free domain-specific language for editing audio files on the fly in a way that is intuitive and easy to learn, with the eventual goal of making even professional audio-mixing more user friendly. Currently, py-DJ is an entirely text-based command-line interface. py-DJ's interface is significantly simpler and more lightweight in comparison to existing audio editing softwares. While there may be concerns with visualization, responsiveness, and loss of detail resulting from scaling a GUI down to a text-based interface, it is important to keep in mind that py-DJ was developed with the user experience as a priority. In addition to a responsive and user-friendly interface, py-DJ offers support for features such as volume adjustment, pitch adjustment, splitting files, concatenation of files, overlaying of files, among others, and will be later expanded to be more feature-rich.

## Language Design Details 
The philosophies behind py-DJ's language design are:

1. To be accessible to all, not just those well-versed in editing audio, or only those new to audio editing
2. To be both clear and concise with the syntax design

Reflecting the first philosophy, py-DJ's design is almost entirely motivated by the user experience. As such, although it may not be as feature rich as similar existing audio editing software, it provides the necessary foundation with its rich user interface for several more features to be developed in the future. Given the unconventional interface, it is difficult to achieve the first philosophy without achieving the second. Because py-DJ is a command-line interface, having verbose and vague syntax design not only further alienates users who are already uncomfortable with audio editing, but also users unfamiliar with command-line. Concise and clear syntax makes the language significantly easier to learn, and falls in line with the "simple interface" theme, thus also further enhancing the user experience.

Users write "programs" in py-DJ through a series of single expressions that indicate some audio effect change in the py-DJ command line interface. The expressions that users can provide, or more succinctly the user inputs, are broadly categorized as either an *effects expression* or a *interface expression*. 

* Effects expression are directly related to modifying audio files. Users provide an effects expression that corresponds to some implemented feature in py-DJ to apply some effect to the current audio file being edited. There is some flexibility for describing effects. For instance, if the user wants to increase the volume, the user types "+ volume 10" to increase the volume of the current audio file by 10 decibels, or, alternatively, "* volume 3" to increase the volume by a factor of 3. All effects expressions are summarized in py-DJ when the user types ` help ` or `?`. More detailed explanations are provided when the user types ` help <effects expression>`.
* Interface expressions are related to interacting with the interface. Users provide an interface expression that corresponds to some interface feature. `help` and `?` are examples of interface expressions. These interface expressions help make py-DJ easier to use, and effectively supplement the visualization provided by the GUI. For instance, users can type `history` to bring up a well-formatted list of recent edits starting from the most recent, `files` to bring up a well-formatted list of audio files in the work space, among others.

Users effectively build up their programs incrementally, applying a wide variety of edits to a variety of songs in their workspace, made possible with a REPL interface, which is one of the tool support py-DJ provides. A REPL interface, also known as interactive toplevel, is a simple interactive computer programming environment that takes single user inputs, evaluates them, and returns the result to the user. The REPL interface allows for extreme responsiveness, as users are able to receive feedback almost immediately once their input is parsed, interpreted, and applied. As such, py-DJ naturally has very effective and immediate error-handling which will be discussed in more detail later. 

Using the REPL interface, the computation model for each iteration parses the user expressions and compiles them into distinct `Rules` objects, which are then tied to certain audio effects. These audio effects are applied to the file and the process is repeated.

To illustrate the REPL interface, effects expressions, interface expressions, and to generally showcase py-DJ, an example "program" is provided below. The example program walks through all effects expressions and interface expressions and attempts to emulate as closely as possible how a user might use py-DJ. 

### Example Program
![alt-text](https://github.com/williumchen/project/blob/master/documents/REPL1.png)
![alt-text](https://github.com/williumchen/project/blob/master/documents/REPL2.png)
![alt-text](https://github.com/williumchen/project/blob/master/documents/REPL3.png)

The syntax of my language helps users write programs more easily than the syntax of a general-purpose language simply because of the limited scope. Anything beyond the scope of the domain of py-DJ, which is audio editing, is impossible. The only thing users can do in py-DJ is define expressions related to audio editing or the user interface. Additionally, py-DJ lacks traditional control-flow structures as well as explicit data structures because, for the scope and time frame of this particular project, they were not absolutely essential. In an abstract sense, the audio files themselves could potentially be considered internal data structures (although they are not implemented as such) when the user `loads` them, as they essentially store all the edits the user provides. 

More generally, the syntax was designed to be as minimalistic as possible: as aforementioned, the syntax was designed to be concise and clear. However, it's not always easy to be concise and clear, and a lot of thought was placed in syntax design. Even then, planning alone ultimately was not enough, and receiving actual user feedback turned out to be necessary. To summarize a few reconsiderations in syntax design:

* I abandoned the idea of syntax revolving around natural language because I felt it was neither concise nor clear. While the use of natural language was tempting because it seemed as if it would attract non-programmers, the associated verboseness and ambiguity was simply not worth it. This isn't to say natural language has no place in py-DJ. Several of the keywords in the syntax are natural langauge-esque. For instance, splitting the current audio file is done by typing `cut 0:03 to 0:10`.
*  Does `file1 + file2` suggest overlaying the two audio files, or concatenating? In a blind user test, where users were given no context, all said it suggested overlaying, which was contrary to how I had implemented it at first.
*  Ordering of `history`. I originally had `history` sorted by oldest edit first, as this was how the actual history of edits were stored in the back-end. However, user feedback and critiques suggested it be ordered by most recent first.
*  `revert 3`. Should the integer simply `undo` the 3 most recent edits, or fetch the third state in `history`. Again, user feedback suggested semantically, `revert` seemed as if it fetches an older state. I later allowed `undo` to also optionally take in an integer.

In terms of language design, I had originally planned to parse a text file with all effects expressions, interpret the parsed result, and apply the results to an audio file. In theory, this seemed like a great idea, and I surprisingly received positive feedback. However, in practice, this was less than ideal for the users. Although easier to implement than the REPL interface, this version of the language was extremely unresponsive, forced the user to complete all edits before listening to them, and delayed all errors until edits were complete.

As the above hopefully demonstrates, I ended up dedicating significantly more time on user interface and language/syntax design than expected. 

Lastly, although there are several ways in which a program can go wrong, the REPL interface lends itself to very elegant error handling. The most common ways a program in py-DJ can go wrong are parse and syntax related errors. As of now, all parse-related errors and syntax-errors are suppressed with `try` and `except` catches such that the REPL does not exit out mid-session. These errors are translated to understandable print statements that are made available to the user immediately after the error was made. With more time permitted, I would have modularized the errors into their own error classes rather than having print statements sprinkled all over the REPL interface code.

This DSL took mild inspiration from the aforementioned audio editing softwares, linked previously. However, the idea to create an entirely text-based, command-line REPL interface as an alternative to existing audio editing software is unique to py-DJ. Although py-DJ and existing software serve the same domain, the two approaches are drastically different. I would argue py-DJ is very different from audio editing software like Audacity or Ableton. The interface alone is completely different, which leads to a completely unique user experience. I genuinely believe py-DJ is, and has the potential to continue being, significantly easier to use even with future features. Perhaps the most significant drawback is the ease of implementing additional features in a GUI compared to implementing additional features in a text-based interface through effective language design.

## Language Implementation

I chose Python as a host language as it is a popular language that I am personally familiar with, and has perhaps the most extensive libraries available for audio manipulation. Additionally, because Python is a high level language, I hope to be able to develop quickly and efficiently, while trying out several ideas without the fear of sinking too much time in the case where these ideas end up not working/being necessary. In particular, because of how easy development in Python can be, I was able to completely refactor my language design from a parsed-document interface to a REPL interface. Additionally, throughout the development process, I was able to change prior syntax design choices upon receiving new user feedback. Although I had experience in developing software in Python, I have no experience doing parsing or using any of the audio manipulation libraries. Because Python is so popular, the resources available helped facilitate a quick learning process. At the same time, the overall development experience was still an interesting and challenging experience.

I decided on an external implementation as it seemed like a better choice for flexibility in syntax design. I felt this flexibility was crucial in order to implement the syntax to be as true to the original design as possible. I really did not want the syntax looking anything like Python, and, more generally, wanted to remove any programming aspects from this DSL. Additionally, I'm not familiar with any language available specifically for editing music, and the built-in syntax for Python, which is a general-purpose language, is not well-suited for py-DJ. 

A library I used to supplement the back-end with is pydub, which is a simple and easy high level interface to manipulate audio files. As an aside, Amit's piece of advice during the presentations resonated particularly well with me. Much of the semantics and back-end relies heavily on pydub. Although I could have easily dumped a large amount of time into developing my own effects expressions, for me, this was not the purpose of the class. A new back-end for audio manipulation could easily come out that will have essentially wasted my time. Therefore, I am quite satisfied having focused primarily on language design and user interface. Another library I used is pyparsing as a parsing tool.

Below is a layout for the architecture of my DSL:

![alt-text](https://github.com/williumchen/project/blob/master/documents/project_architecture.png)

In terms of language architecture, the layout follows the structure described in class relatively closely, starting with the parser, converting to the intermediate representation, and interpreting the intermediate representation and applying effects to the audio file. The architecture is laid out to be extensible and modular, though the parser and IR are in the same file, simply because the IR is very straight forward. Because py-DJ uses a REPL interface, only one line is needed to be parsed at a time.

The first and perhaps most important component will be the parser. The parser defines `Rules` that represent differing effects expressions and interface expressions. Categorizing user expressions as `Rules` ended up working out quite nicely as the user could only input one type of expression at a time due to the nature of REPL. It parses individual expressions the user writes into one of these `Rules` object, which is the intermediate representation. These `Rules` objects are typical Python classes with unique constructors. Both the parser and intermediate representations are found in `parser.py`. The interpreter/semantics , found in `effects.py`, contain most of the audio effects. The final changes to the audio file are applied in the actual REPL interface, found in `repl.py`. In a sense, the REPL interface brings together the parser, the intermediate representation, and the interpreter/semantics.

## Evaluation

I would consider py-DJ to be extremely "DSL-y" in that it is extremely domain specific, and not at all general-purpose. For instance, things that are easy to do, and essentially what the user can do, in py-DJ include basic edits to audio files within the scope of implemented effects. Things that are difficult but possible include building music from scratch, edits at specific time intervals. Things that are impossible include anything outside the scope of audio editing. There lacks any concrete data structures or control flow the user can work with, making py-DJ not Turing complete. 

I am most pleased with the user experience py-DJ provides. The only caveat I have with the user interface now is that it is still a command-line interface. Although I've done my best to take out any programming aspects from the language, it being a command-line interface will still most likely alienate those not extremely familiar with working with the command-line (basically non-programmers). However, even then, I think I've detailed the usage and installation instructions clear enough such that users should be able to use the language without much difficulty. Once the user is in the command-line interface, the language should be completely self-contained and free of most programming elements. 

I really like how the language and syntax design ended up. I think the syntax is extremely easy to write and read, and the overall language is far easier to use than existing audio editing software, which was an initial goal of the project. One thing this project made clear to me is how crucial the user experience is. I found myself subject to what I call "developer bias," where, as developers, we tend to opt for the easier implementation rather than the implementation that benefits the users. This resulted in several instances where I had to refactor the syntax design and even the entire language design.

Although I like where the project is currently, there is definitely a lot of room for improvement. As of now, the effects expressions are rather sparse. Users aren't really able to create anything *pleasant* sounding given the tools py-DJ provides. As such, the current implementation does differ from the larger vision for py-DJ, though, to be fair, the original vision I had of creating something that parallels existing audio editing software was extremely grandiose and ambitious for a half-semester project. I think py-DJ is on the right track and everything was implemented in good faith towards the larger vision. Given more time, I would have looked into additional Python libraries that provide audio manipulations more in line with effect units (such as chorus effect, harmonies, overdrive, etc). pydub is a great library for basic audio effects, but falls short in terms of these effect units. Additionally, although significant work and thought has been placed into user experience and language design, there is more that can be done to improve user experience. For instance, I think introducing a few control structures might actually help the user significantly. Having the ability to apply a particular effect to multiple songs (for loop) in the work space would be a feature that I, as a potential user, would be interested in. Similarly, to make the language more extensible, it would be nice to allow users to create their own effects by combining existing effects expressions in py-DJ (this was a stretch goal that I never got around to). Lastly, it would help if the code was more modularized. I tried my best, but with not a significant amount of time, and refactoring the language design early on, the architecture was not thoroughly planned out. As of now, a lot of the code in `repl.py` extend beyond the scope of implementing the REPL interface. I think a lot of the logic can be placed in an alternate back-end. Similarly, the IR could be in a separate file from the parser. If any of the libraries I currently use were to be replaced by a better alternative, it would involve a significant amount of refactoring.

My evaluation plan from the beginning of the project stated: 

"I will know that my language has accomplished its goals if it could parallel a few basic functions of more established music editing software, namely Audacity given its more simplistic nature. One of the primary ways I hope to evaluate my language design is by trying to personally use it as well as asking peers who I know frequently edit music using professional music editing software to provide some feedback with regard to feature differences and ease of use."

I'd like to say I accomplished most parts of the evaluation plan in that py-DJ does parallel basic functions of Audacity, such as volume and pitch adjustment, cutting audio files, reversing audio files, support for concatenation and overlay, among others. I also ended up seeking a lot of user feedback from both  those with no experience in audio editing and those with significant experience.

I've mentioned most of the significant changes to syntax and language design due to critiques and user tests in the language design section. In terms of trouble I ran into, most of them were just familiarity with the libraries I was working with. Although I am decently familiar with Python, I have never done any parsing, and learning was a bit difficult at first. Besides syntax design and language design, I never really ran into a problem that stumped me for longer than the particular week I was working on it. The only problem that I never resolved was getting recording to work with the command-line interface. I couldn't figure out how to get KeyboardInterruptions to work with threading or the REPL interface, which waits indefinitely for user input. 