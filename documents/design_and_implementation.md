# Language design and implementation overview
## Language design

In my languages a writes programs the same way they would write a Scala program because it is an internal DSL. The main computation my language performs is a translation from the user's written Scala code to SQL queries. The basic data structure in my program is an instance of a Scala Collection. Originally, I thought that my data structure would directly inherit from the Scala Traversable class but I've refined that so now it inherits from a Scala Sequence which is a little bit more specific. The user manipulates control flow in my language the same as they would with any other Scala Collection, by calling functions on that collection. The input to my program consists of these Scala Collections and functions called on the collections. The output is, as previously stated, SQL queries corresponding to these function calls. 

As far as error handling, my stance has not changed much since I began my project. Without my DSL or a similar one, users would be writing SQL statements directly in their Scala code. This is prone to database errors when the query is executed just as much as my language would be. Maybe the user put in the wrong field name for the database or the wrong field type. Currently, I am not planning on implementing error checking for this but if I did have time, I could get some inspiration from a similar DSL in my domain: Slick. Slick users must define a database's schema beforehand and then Slick can do error and type-checking on against that schema. But again, errors can still arise if the schema is defined wrong.

## Language implementation

My choice of an internal DSL was pretty easy to make. The goal of my language was to be able to execute SQL queries in Scala in the most native way possible. What could be more native than an internal DSL. I chose Scala as my host language for two main reasons. The first was that it has all the functional language features. This was a requirement because I was creating a functional-relational mapping. I could have just as easily chosen another functional language however. The reason I chose Scala is that we have been working with it in class and I am much more familiar with creating an internal DSL in Scala than in any other functional language.

After doing more research on my project, I've split it up into three main tasks: creating an intermediate SQL representation, creating a subclass of a Scala Collection, and writing the functions for that subclass. For my first task of creating an intermediate representation, I am going to follow mostly [this](http://www.doc.ic.ac.uk/~pjm/teaching/student_projects/gc106_report.pdf) paper on Relational Algebra abstract syntax. After I have my internal representation, I want to create a Scala class that mimics very well the native Scala collections. For this I plan on studying the Scala [source code](https://github.com/scala/scala/tree/2.12.x/src/library/scala/collection/immutable) for different collections and following that as closely as possible. Finally, once I have a class and an intermediate representation, I feel like writing the translations from my class to SQL syntax will be pretty straightforward.