## Introduction

Every fall and every spring, students across the country struggling with the same feelings of panic, uncertainty and indecision as they are asked to choose the courses that will define their college experience in the subsequent semester. Which core requirements do they need to get out of the way? Which electives should they take now? Which professors should they try to get? During what times of the day and week do they want to be in class? All these questions and more, must be carefully weighed as they try to make the best decision. 

Students at the Claremont Colleges struggle with these same questions. We have some tools to help us visualize the possibilities for the subsequent semester, such as the [Scheduler App](http://scheduler.5capps.com/#) and the [ASPC-Scheduler App](https://aspc.pomona.edu/courses/schedule/), but neither gives the users the full flexibility they may want and need to specify exactly what their preferences are. 

I designed and implemented the CourseScheduler DSL to meet this need by allow students to express their preferences for courses with the fluidity and expressiveness of a DSL. Rather than looking through all the possible schedules with different combinations of the classes they are interested in, students should be able to input a list of all the courses they might be interested in, and then write a program describing the kind of schedule they want, run it, and get a list of the possibly schedules that most closely align with their preferences. CourseScheduler works very well with the Scheduler App which interfaces with the 5C class portal, but CourseScheduler is general enough that it has the potential to be used with classes or schedules at other places as well, as long as the user can generate an initial class list in the correct format.

The essence of CourseScheduler is constraint satisfaction. The user's program (a list of their preferences) provide the constraints which are used to maipulate the database of classes and determine what combinations of classes will generate the most preferred schedules. Additional constraints are then checked to insure that no invalid schedules, such as schedules with overlapping class times, to many or two few classes, or multiple copies of the same class, are generated).

##Language Design Details

The user writes their program by simply typing a list of their preferences, seperated by commas and ending with a period. They can create very long programs if they wish to rate many different professors, sections, classes, time slots, or days. However, because the syntax is limited to these five commands plus two others (See Note 1 Below) which can only be used once (minimum and maximum course load), the language is very simple, easy to use, and specifically applicable to the domain, and it is the only DSL I have seen which appears to work in this domain. There are many data vizualization tools which will display classes, like the [Scheduler App](http://scheduler.5capps.com/#) and the [ASPC-Scheduler App](https://aspc.pomona.edu/courses/schedule/), but none allow the user to write actual programs to explain what they are looking for in an ideal schedule.

When the user runs the program, they are guided by clear and detailed instructions, through all of the necessary steps to generate the schedules which they want. There are very few control structures in the DSL which the user can access, but this is meant to be a protection for them, to keep the language very simple, and because such control structures should not be neccessary for creating schedules. The one big exception to this rule is the users ability, and in fact requirement, to specify at run time how much output they would like. This allows them to determine how much information they want to recieve from the program to insure that it is useful and relevant to their decision about which classes they will take.

The user creates the initial database at runtime with the input generated by the Scheduler App. This input is a giant list of all the classes in which the user is interested, in the form of embedded lists of class information. The user then manipulates the database by stating their preferences for particular characteristics of a class. Finally, the sourceCode file computes the preference value for every possible combination of classes which satisfies the basic restraints for a valid schedule. All of these schedules are lists of embedded lists which are passed from function to function by the sourceCode to check the value and the constrainsts, these are then sorted by value and printed out from most valuable to least or until the number of schedules requested by the user has been printed. The output is text based, although in the future I would like to send the output back to the Scheduler App and display it there. The output includes a schedules ranking, preference, and the number of credits it includes, as well as a list of class sections which it includes and their preference values.

There is basic error checking for all the functions which the user is expected to use. These are in the form of simple, but clear error messages for bad input values and the program still runs with the preferences that it could read, since that piece of data might not have been particularly relevant. The error I expect most often would come from simply mispelling the name of a professor or class and so allowing the program to continue running in spite of this, can show the user that their program is close to working and provide encouragement for novice programmers rather than scaring them away with harsh error messages and discouragement when they don't immediantly see the problem.


(Note 1) These 7 commands are the main ways the user is intended to use the language, although technically they can modify the database directly and then call generateSchedule again, or they could add professors and classes to the database by accessing the methods I used to create the database from the inital input list of classes. This could be useful, if they want to add things which are not available through portal, but should be done with caution.

##Example program(s)

A user's program could look like the program provided in the SampleUserFile.txt and reproduced below:

% A Possible User's Preferences

rateProf('Levy', 5),
rateProf('Lyzenga', 15),
rateProf('Williams', 8),
rateProf('Dodds', 100),
rateProf('Vosburg', 10),
rateProf('Adolph', 6),

rateClass('WRIT001', 5), 
rateClass('MATH030B', 7),
rateClass('CHEM024', 11),

rateSection('CHEM023A', 'HM-01', 8),
rateSection('WRIT001', 'HM-01', 17),
rateSection('ECON104', 'HM-01', 23),
rateSection('MATH035','HM-03', 12),
rateSection('PHYS023','HM-03', 23),

rateTimeBlock(8, 10, -5),
rateTimeBlock(13, 14.5, -5),


rateDay('Monday', -10),
rateDay('Friday', -20),

setMaxCourseLoad(17),
setMinCourseLoad(14).

When the user ran it, they would input the list of classes from which to build schedules (repreoduced below):

[['CHEM023A','HM-01',3,[8,30,2016],[12,16,2016],['Van Hecke','Johnson','Vosburg','Hawkins'],[[0,9,9.833333333333334,'HM Campus, Shanahan Center, 2460'],[2,9,9.833333333333334,'HM Campus, Shanahan Center, 2460'],[4,9,9.833333333333334,'HM Campus, Shanahan Center, 2460']]],
['CHEM023A','HM-02',3,[8,30,2016],[12,16,2016],['Van Hecke','Johnson','Vosburg','Hawkins'],[[0,9,9.833333333333334,'HM Campus, Shanahan Center, 2454'],[2,9,9.833333333333334,'HM Campus, Shanahan Center, 2454'],[4,9,9.833333333333334,'HM Campus, Shanahan Center, 2454']]],
['CHEM023A','HM-03',3,[8,30,2016],[12,16,2016],['Van Hecke','Johnson','Vosburg','Hawkins'],[[0,9,9.833333333333334,'HM Campus, Shanahan Center, 1480'],[2,9,9.833333333333334,'HM Campus, Shanahan Center, 1480'],[4,9,9.833333333333334,'HM Campus, Shanahan Center, 1480']]],
['CHEM024','HM-01',1,[8,30,2016],[12,16,2016],['Haushalter'],[[0,13.25,17.25,'HM Campus, Jacobs Science Center, 2308']]],
['CHEM024','HM-02',1,[8,30,2016],[12,16,2016],['Vosburg'],[[1,13.25,17.25,'HM Campus, Jacobs Science Center, 2308']]],
['CHEM024','HM-03',1,[8,30,2016],[12,16,2016],['Van Heuvelen'],[[2,13.25,17.25,'HM Campus, Jacobs Science Center, 2308']]],
['CSCI005','HM-01',3,[8,30,2016],[12,16,2016],['Dodds'],[[1,8.166666666666666,9.416666666666666,'HM Campus, Shanahan Center, 1430'],[3,8.166666666666666,9.416666666666666,'HM Campus, Shanahan Center, 1430']]],
['CSCI005','HM-02',3,[8,30,2016],[12,16,2016],['Kuenning'],[[1,9.583333333333334,10.833333333333334,'HM Campus, Beckman Hall, B126'],[3,9.583333333333334,10.833333333333334,'HM Campus, Beckman Hall, B126']]],
['MATH030B','HM-01',1.5,[8,30,2016],[10,14,2016],['Omar'],[[1,8.166666666666666,9.416666666666666,'HM Campus, Shanahan Center, 1480'],[3,8.166666666666666,9.416666666666666,'HM Campus, Shanahan Center, 1480']]],
['MATH030B','HM-02',1.5,[8,30,2016],[10,14,2016],['Omar'],[[1,9.583333333333334,10.833333333333334,'HM Campus, Shanahan Center, 1480'],[3,9.583333333333334,10.833333333333334,'HM Campus, Shanahan Center, 1480']]],
['MATH035','HM-01',1.5,[10,19,2016],[12,16,2016],['Martonosi'],[[1,8.166666666666666,9.416666666666666,'HM Campus, Shanahan Center, 3460'],[3,8.166666666666666,9.416666666666666,'HM Campus, Shanahan Center, 3460']]],
['MATH035','HM-02',1.5,[10,19,2016],[12,16,2016],['Martonosi'],[[1,9.583333333333334,10.833333333333334,'HM Campus, Shanahan Center, 3460'],[3,9.583333333333334,10.833333333333334,'HM Campus, Shanahan Center, 3460']]],
['MATH035','HM-03',1.5,[10,19,2016],[12,16,2016],['Williams'],[[1,8.166666666666666,9.416666666666666,'HM Campus, Shanahan Center, B450'],[3,8.166666666666666,9.416666666666666,'HM Campus, Shanahan Center, B450']]],
['MATH035','HM-04',1.5,[10,19,2016],[12,16,2016],['Williams'],[[1,9.583333333333334,10.833333333333334,'HM Campus, Shanahan Center, B450'],[3,9.583333333333334,10.833333333333334,'HM Campus, Shanahan Center, B450']]],
['PHYS023','HM-01',1.5,[8,30,2016],[10,14,2016],['Lyzenga','Chen'],[[3,12.083333333333334,13.083333333333334,'HM Campus, Shanahan Center, 1430'],[0,8,8.833333333333334,'HM Campus, Shanahan Center, B470'],[2,8,8.833333333333334,'HM Campus, Shanahan Center, B470']]],
['PHYS023','HM-02',1.5,[8,30,2016],[10,14,2016],['Lyzenga'],[[3,12.083333333333334,13.083333333333334,'HM Campus, Shanahan Center, 1430'],[0,8,8.833333333333334,'HM Campus, Shanahan Center, 3465'],[2,8,8.833333333333334,'HM Campus, Shanahan Center, 3465']]],
['PHYS023','HM-03',1.5,[8,30,2016],[10,14,2016],['Lyzenga','Sahakian'],[[3,12.083333333333334,13.083333333333334,'HM Campus, Shanahan Center, 1430'],[0,8,8.833333333333334,'HM Campus, Shanahan Center, 2407'],[2,8,8.833333333333334,'HM Campus, Shanahan Center, 2407']]],
['WRIT001','HM-01',1.5,[8,30,2016],[10,14,2016],['Levy','Van Heuvelen'],[[0,8,8.833333333333334,'HM Campus, Shanahan Center, 2421'],[2,8,8.833333333333334,'HM Campus, Shanahan Center, 2421'],[4,8,8.833333333333334,'HM Campus, Shanahan Center, 2421']]],
['WRIT001','HM-02',1.5,[8,30,2016],[10,14,2016],['Levy','Van Heuvelen'],[[0,8,8.833333333333334,'HM Campus, Shanahan Center, 2421'],[2,8,8.833333333333334,'HM Campus, Shanahan Center, 2421'],[4,8,8.833333333333334,'HM Campus, Shanahan Center, 2421']]],
['WRIT001','HM-03',1.5,[8,30,2016],[10,14,2016],['Adolph','Wu'],[[0,8,8.833333333333334,'HM Campus, Shanahan Center, 2425'],[2,8,8.833333333333334,'HM Campus, Shanahan Center, 2425'],[4,8,8.833333333333334,'HM Campus, Shanahan Center, 2425']]],
['ECON104','HM-01',3,[8,30,2016],[12,16,2016],['Evans'],[[1,13.25,14.5,'HM Campus, Shanahan Center, 1430'],[3,13.25,14.5,'HM Campus, Shanahan Center, 1430']]],
['MS 120','HM-01',3,[8,30,2016],[12,16,2016],['Mayeri'],[[1,13.25,14.5,'HM Campus, Shanahan Center, 2421'],[3,13.25,14.5,'HM Campus, Shanahan Center, 2421'],[1,18,20,'HM Campus, Shanahan Center, B480']]]].

Input the name of their program file ('SampleUserFile.txt'.) and the number of schedules to generate (10.) and get the following output in just a few seconds:

Schedule Number: 1 has 14.5 units and a preference value of 120
CHEM023A HM-01 -27
CHEM024 HM-03 11
CSCI005 HM-01 90
MATH030B HM-02 7
MATH035 HM-04 8
PHYS023 HM-03 18
ECON104 HM-01 13

Schedule Number: 2 has 14.5 units and a preference value of 112
CHEM023A HM-03 -35
CHEM024 HM-03 11
CSCI005 HM-01 90
MATH030B HM-02 7
MATH035 HM-04 8
PHYS023 HM-03 18
ECON104 HM-01 13

Schedule Number: 3 has 14.5 units and a preference value of 112
CHEM023A HM-02 -35
CHEM024 HM-03 11
CSCI005 HM-01 90
MATH030B HM-02 7
MATH035 HM-04 8
PHYS023 HM-03 18
ECON104 HM-01 13

Schedule Number: 4 has 14.5 units and a preference value of 112
CHEM023A HM-01 -27
CHEM024 HM-03 11
CSCI005 HM-01 90
MATH030B HM-02 7
MATH035 HM-02 0
PHYS023 HM-03 18
ECON104 HM-01 13

Schedule Number: 5 has 14.5 units and a preference value of 110
CHEM023A HM-01 -27
CHEM024 HM-01 1
CSCI005 HM-01 90
MATH030B HM-02 7
MATH035 HM-04 8
PHYS023 HM-03 18
ECON104 HM-01 13

Schedule Number: 6 has 14.5 units and a preference value of 104
CHEM023A HM-03 -35
CHEM024 HM-03 11
CSCI005 HM-01 90
MATH030B HM-02 7
MATH035 HM-02 0
PHYS023 HM-03 18
ECON104 HM-01 13

Schedule Number: 7 has 14.5 units and a preference value of 104
CHEM023A HM-02 -35
CHEM024 HM-03 11
CSCI005 HM-01 90
MATH030B HM-02 7
MATH035 HM-02 0
PHYS023 HM-03 18
ECON104 HM-01 13

Schedule Number: 8 has 14.5 units and a preference value of 102
CHEM023A HM-03 -35
CHEM024 HM-01 1
CSCI005 HM-01 90
MATH030B HM-02 7
MATH035 HM-04 8
PHYS023 HM-03 18
ECON104 HM-01 13

Schedule Number: 9 has 14.5 units and a preference value of 102
CHEM023A HM-02 -35
CHEM024 HM-01 1
CSCI005 HM-01 90
MATH030B HM-02 7
MATH035 HM-04 8
PHYS023 HM-03 18
ECON104 HM-01 13

Schedule Number: 10 has 14.5 units and a preference value of 102
CHEM023A HM-01 -27
CHEM024 HM-01 1
CSCI005 HM-01 90
MATH030B HM-02 7
MATH035 HM-02 0
PHYS023 HM-03 18
ECON104 HM-01 13


## Language Implementation

 I chose to write my DSL as an internal DSL because I am not very familiar with parsers so I thought it would make more sense for me to make an internal DSL. However, I was also just very interested in Prolog and wanted a chance to work in it. I chose to write an internal DSL in Prolog because I was told that it is a good tool for writing DSLs, it handles database queries and unification algorithms very well and it is a language that really interestes me, which I was able to learn so much about this semester. Prolog is already very close to a DSL so my DSL was really just a set of basic functions I defined for my users to use in Prolog. It is very different than any of the languages used in most CS courses so it was extremely interesting to learn about it and consider the different ways it gave me to address problems I encountered, ideas I expressed, and methods I used to solve them. Part of why we design DSL is because language matters, it shapes the way we think and speak and I wanted (and got!) the experience of implementing a long and challenging program in a very different type of language then I am accustomed.

 I worked with Casey Chu, who designed the Scheduler App and extended his design to include a 'prologify' button to generate the class data in the form of a list I could easily read into my program. I used this to build a Prolog database of facts, and manipulated the user input so it is really just a list of Prolog clauses anded together, so that I could just read it in from their file and immediantly call it. This fits with the extreme simplicity that I was aiming for since Prolog clauses already look so simple and DSL-y, and the ones I created for my users really require no programming background to understand.

 My code is really divided into four main parts. First, I read in the list of classes generated by the Scheduler App, and use it to assert all the facts I want in my database and provide them with initial preference values of 0. Secondly, I read in the users input and manipulate the database, by retracting and asserting new facts based on the users preferences. Thirdly, I generate the values of all the classes from the values of all their components. Finally, I create a list of all the possible schedules and their values, by creating lists of all the possible combinations of course sections and then checking if they form a valid schedule (enough credits, no overlapping times, no multiple sections of the same course). I sort this list and then print the number of valid requested schedules with the highest preference values.

## Evaluation

My code is fairly DSL-y. It is not very far from Prolog, and in some sense it really is just Prolog, but Prolog that has been bent to this particular purpose and shaped so that when the user runs the program as instructed, it will generate the desired schedule. Prolog is already very different from most Programming languages and in many ways provides the feel of a DSL, because of the simplicity with which a user can make statements. I am very pleased with the way I manipulated the lists to give me back all the possible schedules in descending order. I spent a lot of time considering different sorting methods and ways of checking for valid schedules, but because I was using Prolog, I realized I didn't really need any of those searching or sorting algorithms, because those are built into the computational model that Prolog depends on. I didn't need to tell Prolog how to do it, any more than I need my users to tell me how to generate their schedules. I just needed to tell it what I wanted and allow it to determine how to accomplish that.

I would still like to modify the output so that the user has the option of getting all of the potental schedules which were generated, outputted to a a visualization tool like the Scheduler App in descending order, so rather than getting a text based list of all the most highly ranked schedules, the user could simply click through and see what each schedule would look like. I would also like to continue figuring out how to check that the user is only calling one of the functions they are supposed to call (and not any private functions I created for me to manipulate the class data). I spent quite a while looking at ways of dividing my code across several files and using modules or consult() to make some methods inaccessible to the user. However, I couldn't find a way which entirely worked which allowed me to insure that they were only using one of the methods I defined for them, but which allowed my methods to still do everything I needed them to do, like modifying the database of all my facts. I couldn't find useful examples of things online, or better ways of reading clauses which I want to call from a file. I also wanted to add more features to allow the user to specify more detailed things about times, but couldn't determine how to provide the users with ways to say all of the things they might want to say about their time preferences, so I was forced to limit myself to just a few of the most basic time specifications.

I have modified my implementation a lot based on user feedback, as I have discussed with people around my dorm, what they think is the most intuitive way of saying certain things, but I have also been forced to make some difficult decisions when many people had different opinions baout a particular design choice. One big change that I wanted to make after spending a lot of time debugging, was to change the underlying data structure from a list to something else, because it felt very challenging to come back to my project after a few days of not looking at it and remember what all my methods did and keep track of what layer of embedded lists a particular method was pulling apart. However, at that point in time, it seemed unwise to try to redesign my basic structure since I only had a little while left to work on the project. I have, however, become significantly better at reasoning about Prolog code (stay away from 'or statements' because they can evaluate to true in multiple ways), at debugging (if nothing looks wrong in the line the error says it is on, look at the 5 lines above it), and at making tradeoffs so that even if things don't work perfectly, I at least have something (I just implemented the basic time functions and let go of the other possibilities). 






