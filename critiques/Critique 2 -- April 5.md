It looks like you made a lot of progress this week! I have a few comments that will hopefully help for next week and beyond, or at least give you some things to think about for the rest of the project. Even though your users will be using your DSL and not general Prolog, it's still a bit of a weird language. Be sure to think about who you want the end user to be. Do they have experience with programming? Do you think they would want to deal with something very similar to a programming language when trying to schedule classes? These are questions that should probably be asked later in the project, since functionality is key for now. It doesn't hurt to keep this in mind, since the entire system is designed for the end user.

It sounds like you came up with a great way to get to the meat of the problem and avoid all the complications of dealing with Portal. Later on in the project, would you consider pulling data from Portal or having some other way to generate data? One suggestion for this would be to look at Casey's code and see how he's implementing the current button. There might be a better way to get the data in the format you want than by going through the Scheduler UI. It seems more efficient to make that happen behind the scenes, so maybe intercept the data before it appears on the UI and feed it directly into your program. Again, that's definitely a problem for later in the project, you've got the right idea to prioritize the actual scheduling algorithm.

With regards to your Prolog/Eclipse struggles, where were you getting stuck? Did it have to do with Eclipse in general, or the IDE you were using? If you find yourself wanting more testing/debugging functionality in the future, it might be worth looking into one of the Eclipse-based Prolog IDEs. It looks like [PDT](https://sewiki.iai.uni-bonn.de/research/pdt/docs/start) has the greatest amount of resources and support, but I also found [ProDT](http://prodevtools.sourceforge.net/) and [SPIDER](https://sicstus.sics.se/spider/) that could be worth researching.

One thing you mentioned in your work for this week was the decision to format all of the class information in lower case. This makes sense due to Prolog's naming constraints. However, you also mention that a command in the language could be formatted like `rateProf(ben, 10)`. You were asking in class about whether these function names were linguistically intuitive. You also ask in your journal if there are things to add that would give it a stronger language feel. In terms of a programming language, I think that you have a good set of commands and that the language is on track to accomplish the specific task that you want. If you want it to have a more intuitive semantic feel, you could consider writing a very simple external DSL on top of this project. To input the above command, the user could type something like `rate Ben 10` or `rate CSCI111 10`. That way, you wouldn't have to worry about capitalization (just convert everything to lower case when parsing in the internal syntax) and the language would read better. This seems like it could snowball out of scope very quickly (as tends to happen with an external DSL) so it's probably not feasible for this project. One other thing that those examples made me consider is how you plan to deal with duplicate data attributes. Will your system be able to handle two profs with the same last name? 

I can't think of many other attributes to categorize classes. If you really want, you could do something like rateDept(Dept, Value) that would rank all classes in a certain department (such as CS) higher. Be sure to think about your scoring function. Do you want all of these ranking attributes to have the same weight in determining the final scores for each class? 

With regards to the timing conflicts and how to represent the start and end times of each class, hopefully the advice we gave in class was helpful! By representing all times in military time and including an integer before time to denote day of week, your comparison logic might get a bit easier. I still think that half/full semester courses could be represented by a simple additional parameter and you could have some simple logic to determine if courses overlap (i.e. if a full semester course is being compared to anything at the same time, it overlaps, but if courses from opposite half semesters are being compared, they could work). 
