# Language design and implementation overview

## Language design
As I decided before, users will write programs in my language through text input in the style of LaTeX. I have not decided the details of the intermediate representation for my language, but there will be one. When a program runs, the text input is parsed and interpreted into an equivalent intermediate representation. Just as my syntax will be a shorthand for guitar tab, the intermediate representation will include all the information contained in a tab, but in a less human-readable format.
Essentially, this means that it will store all information pertaining to the notes in the tab--this will probably still be in terms of fret and string rather than actual pitch for reasons I'll go into shortly. Given that, the intermediate representation will also need to include some metadata like how the guitar should be tuned. This language is very much using a data interpretation model. Once the intermediate representation has been created, the behavior of a program can be one of two things depending on which the user requests. This is the closest thing to control flow that this language will have.

The possible outputs will be PDF, MIDI, LilyPond, and TuxGuitar-readable files, depending on what the user asks for. The PDF and LilyPond outputs can include just standard notation, just tab, or both.

Most errors in this language will be syntax errors. Errors will be communicated as compile-time errors typically are--that is, with some kind of text output. My syntax will likely be similar to that of VexTab; as an example, if the user just writes a number instead of number/number or number-number/number, rather than saying "expected / or -, found ' '", the error message will be something along the lines of "this note is missing the string number". One non-syntax error that will be
very important to deal with is the consistency of time signature and the quantity and duration of notes in each measure. First of all, it needs to be difficult to make this error in the first place. It will not be the user's responsibility to indicate where measures end (although they will be permitted to use some delimiter for their own convenience, like in LilyPond), and the language will understand measures to end based on the duration of notes. So if a program specifies a 4/4 time signature and there are 5 quarter notes at the beginning, any output will have the first
measure end after the first four notes. Sometimes this will not be possible--if the program specifies a 4/4 time signature but has three quarter notes followed by a dotted quarter note, there will be an error. The program will be terminated if such an error occurs, and the user should get a message saying that some measure's notes had too great a total duration and saying which measure that was. Perhaps if I continue working on this project after the class I will let the language be
more flexible and reflect what the user probably means; in that example the user probably intends the durations literally, and so in a more flexible version of the language the first three quarter notes would be interpreted as-is, and the dotted quarter note would be broken into a quarter note in the first measure tied to an eighth note in the second measure.

I do not intend to provide any tool support at this time.

I have mentioned VexTab in the paragraph above; there is a link to it in the first critique in this repository. Like my language, VexTab can output formatted standard notation and/or tab as well as MIDI. It is quite similar to my language and I intend to take some inspiration from it as I've said, but my language should also output files readable by GUI tab editors whereas VexTab does not.

## Language implementation
I've chosen to implement this as an external DSL. I (and just about everyone else who's worked on a music notation DSL, apparently) feel that the data interpretation model is a natural choice for the domain since notation itself is essentially a list of data, and internal DSLs are not as well suited to that computational model.

I have chosen Python as my host language. Both Scala and Python have good parsing tools, but I'm more familiar with Python and my final product will probably be of higher quality for my choice. I've been warned that using Java or C++ (which are the other languages with which I'm sufficiently comfortable to do a largish project) would be an exercise in frustration compared to Scala or Python on account of the parsing tools available. My language will need to call some Java code in
order to write files that TuxGuitar can read, but there are libraries to do this in Python, so this is also not a concern.

I have decided that my syntax will be a shorthand (and probably similar to VexTab and/or LilyPond), and I have done so for two reasons. The first is that in the use-case where a user is creating an entirely new tab, it will be much faster to type in shorthand than use typical ASCII tab as typically found on the internet. I've tried writing both ASCII tab and VexTab, and the latter is far easier. The other reason for my preference of shorthand over ASCII tab is that users who want to
check tabs found on the internet will have less to be frustrated by. If the syntax resembled ASCII tab, users might want to be able to copy and paste tab into a text file and use that as a program. The problem is that internet tab doesn't really follow any particular conventions--for example those tabs that include any rhythm notation at all do not write it the same way as one another.

The part of the architecture that I need to code myself is all middle- or front-end. On the front, I will have a parser, written in Python, that will take in text files and convert them into the intermediate representation. I will write the parser using one of a few parsing libraries that parse according to PEGs, since my language should not be context-free but I may need some more freedom than a regular grammar would provide. I have not completely decided the details just yet,
but I intend to make it have similar structure to TuxGuitar's internal representation, but with less overhead since I don't have to do as much with it. TuxGuitar has separate objects for each note--I'll store notes as numbers in lists, or maybe characters in strings. There will be two backends, each of which is already written. For PDF and MIDI output, I will transpile my language into LilyPond and then run LilyPond on the transpiled program. TuxGuitar is an open source project and provides various
utilities as a library separate from the application--included in that is the internal representation of songs as well as the code that writes to files. I will use this library to output files that TuxGuitar can read.
