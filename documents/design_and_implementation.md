# Language design and implementation overview

## Language design

Currently, a user writes programs in my language by simply inputing a list of courses they are interested in and then specifying how much they value or don't value a specific course characteristic. I am still writing the code to generate possibly schedules with the highest value combination of classes, but once I finish they will be able to specify details about how many schedules they want, how busy they want their schedules to be and run their program which will then output possible schedules.

The basic computation my language performs is unification to combine classes into a schedule based on various weights and time conflicts. The user will use a link on the [Scheduler App](http://scheduler.5capps.com/#) created by Casey Chu which will generate the class data in the correct format to be read into their program and generate a database of facts based on those classes. This database is required for a program in my DSL to run. The program will therefore have a list of professors, times, classes, sections ect. which won't be directly visible to the user, but for which they can input their preferences with basic commmands following the format of rateProf(Name, Value). These rating commands allow the user to manipulate the database, and then to run the program they will provide spefific information about the types of schedules they want generated and the program will generate possible class schedules which maximizes the value of the classes they will be taking.

The program will not work correctly if their class information is not input in the correct format which is why the users will be encouraged to use the exact list output by the Scheduler App. If they try to rate a professor, class, or other element of a course which doesn't exist in the database the program will simply output False when it tries to evaluate the command since it is implemented in prolog. I would like to develope better error-checking tools for my users but due to time constrainst will most likely not have time. The existing work in this domain is mostly in the form of the two apps used by most 5C students to simply display schedules based on the classes they input. The [Scheduler App](http://scheduler.5capps.com/#) and [The ASPC Schedule App](https://aspc.pomona.edu/courses/schedule/) but neither of these allow students to give weights to elements of various courses, They simply provide all possible schedules for a given set of classes.

## Language implementation

I chose to write my DSL as an internal DSL because I am not very familiar with parsers so I thought it would make more sense for me to make an internal DSL. However, I was also just very interested in Prolog and wanted a chance to work in it. I chose to write an internal DSL in Prolog because I have been told that it is a good tool for writing DSLs, it handles database queries and unification algorithms very well and its a language that really interestes me, which I am hoping to learn a lot more about. Prolog is already very close to a DSL and is very different than any of the languages used in most CS courses so I think it will be enjoyable to learn about it and because of the different sort of language I am using, it will shape the types of problems I encounter, ideas I express, and methods I use to solve them. Part of why we design DSL is because language matters, it shapes the way we think and speak and I want the experience of implementing a long and challenging program in a very different type of language then I am accustomed to as a way for me to broaden the way I think about problems in CS.

One of the big decisions I made this week was to have all the class data in all lower case lettering rather than as strings with quotes, but normal capitalization. This decision was very difficult. Because I am using Prolog, if a user types in rateProf(Ben,10). Ben will be interpretted as a variable rather than as a specific professor to search for in the database. I decided that the two most intuitive ways to  phrase the command which Prolog would allow were either rateProf("Ben", 10) or rateProf(ben, 10). Based on the small amount of crowd sourcing I did, I believe that people would prefer to latter option because it is simpler and fewer characters to type, especially for people inputting a long and complicated list of preferences.

Therefore, the input from the Scheduler App will be a list of the form:

[phys024, hm-06, [lynn, gerbode, nichols], [ [[m, w], 800, 850, hm, 'shanahan center', b470], [[t, r], 810, 925, hm, 'shanahan center', 1430]]].

And a user can simply paste it into their program. They may then specify as many of thier preferences as they would like based on professors, class sections, courses themselves, times, dates, and such. These will all be stored as value pairs in the database such as prof(ben,10) or day(m, -2) if someone likes professor Ben a lot but dislikes monday courses. If they do not specify a preference for a particular class atttribute, it will be default initialized to 0. The user may then specify details about the schedule they want and run the program to generate possible schedules.
