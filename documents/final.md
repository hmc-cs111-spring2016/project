## Introduction

Abstract animation is an incredibly broad domain, with a staggering variety of techniques used to create different pieces of art. Because it is so broad, it can be helpful for an animator to restrict their focus so that they do not have to worry about the massive variety of different techniques available to them. ContextSensitive is a domain-specific language that attempts to present one particular way of restricting abstract animation so that it is a more approachable domain for more people, and so that experts can see a new way of approaching the subject.

No single tool for creating abstract animation will ever be sufficient. Overly general tools are useful for experts who know exactly what kinds of things they want to do, but for novice animators those tools may be daunting in the number of options they provide, or may have unintuitive interfaces. Very specific tools are useful for doing what they are intended to be good at, but not for other kinds of animations which may be harder to create. Because of this, it makes sense to create a wide variety of different applications for generating abstract animations, each of which specializes in creating a certain kind of animation, using a certain technique, or thinking about animation in a certain way. ContextSensitive is one such language that can serve as a start to such a collection.

## Language design

ContextSensitive is inspired heavily by ContextFree, a language which allows the creation of abstract images. ContextFree excels at creating fractal art and other art that contains repeated, modified instances of the same basic shapes. Building on this idea, ContextSensitive allows users to build animations based on repeated, modified instances of basic animations, known as animation primitives or simply primitives. A program written in ContextSensitive can be thought of as divided into four main sections:

* Metadata, which contains information such as the size of the canvas, the number of frames and framerate of the animation, and so on.
* Shapes, which currently consist of rectangles, ellipses and triangles. The user can specify a shape's location, size, color, and other properties.
* Primitives, animations where each frame is a single shape. Frames of primitives can be specified as specific shapes, or by applying modifications to previous frames.
* Rules, which can call on primitives to render them or call on themselves or other rules recursively. Each time a primitive or rule is called, the user can specify a set of modifications to apply, which will "stack" with any other modifications already imposed on the rule being executed.

When a program is executed, it builds a scene by calling these rules in order to determine what primitives should appear on the canvas, where, and with what modifications. By restricting programs to have only these four main sections, animators using the language need not worry about anything other than them. A user need only focus on what kinds of shapes they want, how they want to build those shapes into primitives, and how they want to build those primitives into animations. Focusing on this way of thinking allows a different kind of creativity to come to the forefront in animations generated by ContextSensitive.

The language currently does not offer extensive error checking. There are a few errors that are caught and explained to the user (for instance, trying to call a primitive that does not exist in a rule). However, general syntactical errors are not caught well. Future iterations of the language will likely improve on this and allow more specific error messages, particularly for syntax errors. 

My example programs and their outputs can be found in the project code repository: landscape.txt, slowrandomfade.txt, and squirbles.txt (the first two written entirely by me, the third written by Matt Valentine based on another program that I had written). The corresponding mp4 files of output are also there.

## Language implementation

ContextSensitive is an external DSL implemented in python, as it was the first language that I found that had a sufficient rendering library for the project. Nothing else about python made the language particularly harder or easier to implement. It is possible that some efficiency may be gained, however, by moving to a different language. An external DSL is necessary for the kind of close control over syntax that I wanted to have in order to create the "partitioned" source code files.

The front end of the language is simply a text file. Ideally, I would like to have a sort of "template file" that contains all of the necessary sections, and perhaps some kind of IDE similar to the one that ContextFree sports. Parcon, a python parsing library, is used to parse the text file into an intermediate representation which is, at its core, a set of dictionaries. There is a dictionary for rules, a dictionary for primitives and a dictionary for shapes. When the program is run, the first rule in this dictionary is executed, and it determines what other rules or primitives to call by looking them up in the dictionaries by name. This is used to determine the set of all primitives that will appear in the animation. To render a single frame of the animation, then, each primitive is told to render itself and then increment its own frame counter. To render itself, a primitive checks which shape is in its current frame, and PIL (the python imaging library) is used to render the shape. This is repeated until every frame is rendered, and they are then stitched together with FFmpeg (if the user desires). 

At each step of the process, the program keeps track of what modifications need to be applied to rules or primitives or shapes and applies them when necessary. An object-oriented paradigm is used to implement shapes, primitives, rules, modifications and more. When a modification object is applied to a primitive, it has two components: the first are any modifications that directly modify the primitive (such as delaying the start of the primitive), and the second modify each individual frame of the primitive (such as translating the primitive to the right by ten pixels). Both of these kinds of modifications are kept track of using the object-oriented paradigm.

The semantics of ContextSensitive are completely different from those of python; it feels like a completely different language with nothing in common. Its semantics are fairly similar to those of ContextFree. The user specifies each of these components of the animation, and those components directly correspond to their object representations, along with whatever modifications are specified.

## Evaluation

ContextSensitive is completely a domain-specific language. It does not feel like a general-purpose language in any way except for the paradigm of programming, namely that you type a program into a text file and then execute that text file. Apart from this, there are many aspects of the language that decisively separate it from the realm of general-purpose programming. The most obvious of these is that the execution of a program directly renders an animation. Beyond this, however, the segmentation of program files into different sections also brings the language away from a general-purpose feel. There are similar things in general-purpose languages (such as having a section for imports at the top of the file) but nothing so fundamental to the method of programming. 

I think the best success of the language is that I feel like users of the language could genuinely surprise me with what they could do with it. I can imagine a user making something in my language that makes me wonder how they did it. I think this is extremely important because it means that I may have succeeded in more or less transcending the limitations that are imposed by myself. Essentially many similar tools are ultimately only going to be capable of what their creators think they are. This is because the features of the tool are all implemented by the tool's creator, meaning that the user is limited in what they can do by what the creator thought of as possible. It's my hope that because the language is general enough, this restriction is not that severe except for how it is intended to be.

This brings me to the second major success that I see: I believe I have restricted what the user is allowed to do to an appropriate degree. They are restricted enough that they will be forced to think about the domain in a particular way, which will hopefully be different from how they have thought of it in the past. But the language is general enough that there are still a ton of different things they can do. I think this is largely due to my having based it off of ContextFree, which also has this property. I think I've managed to emulate that aspect of ContextFree and extend it into the domain of animation effectively.

There are tons of other things that I'd loved to have implemented. Most of these, however, are only small features in the sense that all they would do is add some additional ability that the user could control. Some small ones that come to mind:

* More general shapes (like general polygons). 
* Some more modifications (in particular, I'd love to give the user the ability to modify the framerate of an individual primitive, which I have an idea for how to do).
* Multiple shapes in the same frame of a primitive.

The first and third of these are also actually language implementation problems, because they would need new syntax elements to specify them.

There are also some more high-level features I'd like. I dislike the current way that the program is called from the command line. I'd really like something like what ContextFree has, a packaged application that can be run more easily and with less technical knowledge. I looked into creating this at one point but I couldn't figure out how to do it simply in python. I think this would greatly improve the user experience. Beyond this would be some kind of custom IDE like ContextFree's, which could theoretically support features like syntax highlighting, automatic templated file generation, and even things like previewing a single frame of the user's choice in the IDE (like ContextFree's preview). I think my implementation is fairly cohesive but there are a couple of features that I added that I have now implemented in better ways (like separately-specified start times for shapes). There are a couple other features that I'm not sure that I handled as well as possible, mostly the recursive depth limit, which is currently handled with a "global" limit at the top of the file, which can be overridden for any individual rules. This isn't entirely intuitive but I am not sure how to do this simply and intuitively. Again ContextFree has a wonderful answer to this by simply detecting when shapes get too small or large but I'm not sure if the same solution would be useful here because of the extra dimension of modifications complicating things. 

Another high-level feature that would improve user experience a lot is better error checking. I think this might be the first thing I implement if I work more on the language. I have an idea for it but am unsure of the details of how to implement it. Specifically, when Parcon fails to parse something, it gives an indication of which character it failed it. I just need to figure out how to get that information out of the exception that it throws, and then map that to a line in the program and I can give the user a better indication of where they had a syntax error. I don't think there are any other particular error-checking problems that wouldn't be solved with a general indication of where syntax errors were. I think individual lines are simple enough that users will be able to figure out what was wrong from this. I also did implement a sort of hotfix for the most annoying of these errors that I kept making (typing decimals without zeroes before the decimal point, i.e. .6 instead of 0.6) by simply adding a zero if there is none.

Looking back at my plan, I mentioned intuitiveness, efficiency and extensibility. I think my language is fairly intuitive, but I suppose I'm not the best judge of this, although others have been able to code in it fairly easily. I'm not sure what kind of benchmarks I should have been looking for in terms of efficiency. Some programs (for instance the slowrandomfade example) take a very long time to render. I think this is a necessary evil of the domain, however. In terms of extensibility I'm honestly not sure how to judge if what I've written is extensible; in theory I don't _think_ it's extensible right now but I think it would be with small changes. In theory it might be possible for another user to specify new modifications by simply specifying the static function that creates it, or new shape types by just defining the draw method that interfaces with PIL. I frankly never ran into any particular difficulties. There were certain features that I wanted to implement but couldn't easily such as packaging everything together into an application or executable, but none of those features were ever in the original scope of the project. I may look into options for those in the future.

In summary I'm really, really happy with the ultimate state of the language. I am excited for the prospect of continuing to work on it without the time pressure of it being for a class. I think I've had to face a lot of difficult language design decisions throughout the project and I think I handled them well enough to create a good language on the whole. 
