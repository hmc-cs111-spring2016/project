# py-DJ
## Introduction

Given how popular electronic music has become, several fans probably have a few of their own novel ideas, but no outlet for them. Most existing [audio](https://www.ableton.com/en/shop/) [mixing](https://itunes.apple.com/us/app/logic-pro-x/id634148309?mt=12) software is not only very pricey, but also extremely complicated. Even open-sourced [alternatives](http://www.audacityteam.org/) that are significantly cheaper remain are no easier to use than their expensive counterparts. It is important to note that these existing pieces of software are extremely powerful. However, as a result, they have also become increasingly unintuitive and genuinely intimidating for first-time users. Simply learning how to perform the most basic of tasks such as adjusting volume or splitting files can take anywhere from 25 minutes to as long as 2 hours. 

This language hopes to help amateurs who simply want some exposure to audio mixing without the time or capital investments. Most audio mixing softwares aim to emulate all the functionality associated with a DJ console, including allowing for most effect units and raw manipulation of the sound files. To facilitate this emulation, most audio editing software has developed a GUI, which, to most, seems like a natural decision. A GUI provides visualization of abstract concepts, responsiveness, and, in theory, ease of use. However, to me, I believe there is a fine line separating the complexity of features and ease of use that has long since been crossed. Although a GUI still provides visualization and responsiveness, I would argue that the user interface could be more effectively designed to accommodate both amateur and professional audio editors. In particular, I felt audio mixing could be more effectively done through a well-designed language and an entirely text-based interface. Although an unconventional approach, through effective language design, a text-based interface could provide responsiveness and a sense of "visualization" while maintaining the "easy to learn" aspect made possible because of the simple interface. The idea is to make the learning curve necessary to edit music significantly less intimidating.

### Currently
py-DJ is a free domain-specific language for editing audio files on the fly in a way that is intuitive and easy to learn, with the eventual goal of making even professional audio-mixing more user friendly. Currently, py-DJ is an entirely text-based command-line interface. py-DJ's interface is significantly simpler and more lightweight in comparison to existing audio editing softwares. While there may be concerns with visualization, responsiveness, and loss of detail resulting from scaling a GUI down to a text-based interface, it is important to keep in mind that py-DJ was developed with the user experience as a priority. In addition to a responsive and user-friendly interface, py-DJ offers support for features such as volume adjustment, pitch adjustment, splitting files, concatenation of files, overlaying of files, among others, and will be later expanded to be more feature-rich.

## Language Design Details 
The philosophies behind py-DJ's language design are:

1. To be accessible to all, not just those well-versed in editing audio, or only those new to audio editing
2. To be both clear and concise with the syntax design

Reflecting the first philosophy, py-DJ's design is almost entirely motivated by the user experience. As such, although it may not be as feature rich as similar existing audio editing software, it provides the necessary foundation with its rich user interface for several more features to be developed in the future. Given the unconventional interface, it is difficult to achieve the first philosophy without achieving the second. Because py-DJ is a command-line interface, having verbose and vague syntax design not only further alienates users who are already uncomfortable with audio editing, but also users unfamiliar with command-line. Concise and clear syntax makes the language significantly easier to learn, and falls in line with the "simple interface" theme, thus also further enhancing the user experience.

Users write "programs" in py-DJ through a series of single expressions that indicate some audio effect change in the py-DJ command line interface. The expressions that users can provide, or more succinctly the user inputs, are broadly categorized as either an *effects expression* or a *interface expression*. 

* Effects expression are directly related to modifying audio files. Users provide an effects expression that corresponds to some implemented feature in py-DJ to apply some effect to the current audio file being edited. There is some flexibility for describing effects. For instance, if the user wants to increase the volume, the user types "+ volume 10" to increase the volume of the current audio file by 10 decibels, or, alternatively, "* volume 3" to increase the volume by a factor of 3. All effects expressions are summarized in py-DJ when the user types ` help ` or `?`. More detailed explanations are provided when the user types ` help <effects expression>`.
* Interface expressions are related to interacting with the interface. Users provide an interface expression that corresponds to some interface feature. `help` and `?` are examples of interface expressions. These interface expressions help make py-DJ easier to use, and effectively supplement the visualization provided by the GUI. For instance, users can type `history` to bring up a well-formatted list of recent edits starting from the most recent, `files` to bring up a well-formatted list of audio files in the work space, among others.

Users effectively build up their programs incrementally, applying a wide variety of edits to a variety of songs in their workspace, made possible with a REPL interface, which is one of the tool support py-DJ provides. A REPL interface, also known as interactive toplevel, is a simple interactive computer programming environment that takes single user inputs, evaluates them, and returns the result to the user. The REPL interface allows for extreme responsiveness, as users are able to receive feedback almost immediately once their input is parsed, interpreted, and applied. As such, py-DJ naturally has very effective and immediate error-handling which will be discussed in more detail later. 

Using the REPL interface, the computation model for each iteration parses the user expressions and compiles them into distinct `Rules` objects, which are then tied to certain audio effects. These audio effects are applied to the file and the process is repeated.

To illustrate the REPL interface, effects expressions, interface expressions, and to generally showcase py-DJ, an example "program" is provided below. The example program walks through all effects expressions and interface expressions and attempts to emulate as closely as possible how a user might use py-DJ. 

### Example Program
![alt-text](https://github.com/williumchen/project/blob/master/documents/REPL1.png)
![alt-text](https://github.com/williumchen/project/blob/master/documents/REPL2.png)
![alt-text](https://github.com/williumchen/project/blob/master/documents/REPL3.png)

The syntax of my language helps users write programs more easily than the syntax of a general-purpose language simply because of the limited scope. Anything beyond the scope of the domain of py-DJ, which is audio editing, is impossible. The only thing users can do in py-DJ is define expressions related to audio editing or the user interface. Additionally, py-DJ lacks traditional control-flow structures as well as explicit data structures because, for the scope and time frame of this particular project, they were not absolutely essential. In an abstract sense, the audio files themselves could potentially be considered internal data structures (although they are not implemented as such) when the user `loads` them, as they essentially store all the edits the user provides. 

More generally, the syntax was designed to be as minimalistic as possible: as aforementioned, the syntax was designed to be concise and clear. However, it's not always easy to be concise and clear, and a lot of thought was placed in syntax design. Even then, planning alone ultimately was not enough, and receiving actual user feedback turned out to be necessary. To summarize a few reconsiderations in syntax design:

* I abandoned the idea of syntax revolving around natural language because I felt it was neither concise nor clear. While the use of natural language was tempting because it seemed as if it would attract non-programmers, the associated verboseness and ambiguity was simply not worth it. This isn't to say natural language has no place in py-DJ. Several of the keywords in the syntax are natural langauge-esque. For instance, splitting the current audio file is done by typing `cut 0:03 to 0:10`.
*  Does `file1 + file2` suggest overlaying the two audio files, or concatenating? In a blind user test, where users were given no context, all said it suggested overlaying, which was contrary to how I had implemented it at first.
*  Ordering of `history`. I originally had `history` sorted by oldest edit first, as this was how the actual history of edits were stored in the back-end. However, user feedback and critiques suggested it be ordered by most recent first.
*  `revert 3`. Should the integer simply `undo` the 3 most recent edits, or fetch the third state in `history`. Again, user feedback suggested semantically, `revert` seemed as if it fetches an older state. I later allowed `undo` to also optionally take in an integer.

In terms of language design, I had originally planned to parse a text file with all effects expressions, interpret the parsed result, and apply the results to an audio file. In theory, this seemed like a great idea, and I surprisingly received positive feedback. However, in practice, this was less than ideal for the users. Although easier to implement than the REPL interface, this version of the language was extremely unresponsive, forced the user to complete all edits before listening to them, and delayed all errors until edits were complete.

As the above hopefully demonstrates, I ended up dedicating significantly more time on user interface and language/syntax design than expected. 

Lastly, although there are several ways in which a program can go wrong, the REPL interface lends itself to very elegant error handling. The most common ways a program in py-DJ can go wrong are parse and syntax related errors. As of now, all parse-related errors and syntax-errors are suppressed with `try` and `except` catches such that the REPL does not exit out mid-session. These errors are translated to understandable print statements that are made available to the user immediately after the error was made. With more time permitted, I would have modularized the errors into their own error classes rather than having print statements sprinkled all over the REPL interface code.

This DSL took mild inspiration from the aforementioned audio editing softwares, linked previously. However, the idea to create an entirely text-based, command-line REPL interface as an alternative to existing audio editing software is unique to py-DJ. Although py-DJ and existing software serve the same domain, the two approaches are drastically different. I would argue py-DJ is very different from audio editing software like Audacity or Ableton. The interface alone is completely different, which leads to a completely unique user experience. I genuinely believe py-DJ is, and has the potential to continue being, significantly easier to use even with future features. Perhaps the most significant drawback is the ease of implementing additional features in a GUI compared to implementing additional features in a text-based interface through effective language design.

## Language Implementation

I chose Python as a host language as it is a popular language that I am personally familiar with, and has perhaps the most extensive libraries available for audio manipulation. Additionally, because Python is a high level language, I hope to be able to develop quickly and efficiently, while trying out several ideas without the fear of sinking too much time in the case where these ideas end up not working/being necessary. In particular, because of how easy development in Python can be, I was able to completely refactor my language design from a parsed-document interface to a REPL interface. Additionally, throughout the development process, I was able to change prior syntax design choices upon receiving new user feedback. Although I had experience in developing software in Python, I have no experience doing parsing or using any of the audio manipulation libraries. Because Python is so popular, the resources available helped facilitate a quick learning process. At the same time, the overall development experience was still an interesting and challenging experience.

I decided on an external implementation as it seemed like a better choice for flexibility in syntax design. I felt this flexibility was crucial in order to implement the syntax to be as true to the original design as possible. I really did not want the syntax looking anything like Python, and, more generally, wanted to remove any programming aspects from this DSL. Additionally, I'm not familiar with any language available specifically for editing music, and the built-in syntax for Python, which is a general-purpose language, is not well-suited for py-DJ. 

A library I used to supplement the back-end with is pydub, which is a simple and easy high level interface to manipulate audio files. As an aside, Amit's piece of advice during the presentations resonated particularly well with me. Much of the semantics and back-end relies heavily on pydub. Although I could have easily dumped a large amount of time into developing my own effects expressions, for me, this was not the purpose of the class. A new back-end for audio manipulation could easily come out that will have essentially wasted my time. Therefore, I am quite satisfied having focused primarily on language design and user interface. Another library I used is pyparsing as a parsing tool.

Below is a layout for the architecture of my DSL:

![alt-text](https://github.com/williumchen/project/blob/master/documents/project_architecture.png)

In terms of language architecture, the layout follows the structure described in class relatively closely, starting with the parser, converting to the intermediate representation, and interpreting the intermediate representation and applying effects to the audio file. The architecture is laid out to be extensible and modular, though the parser and IR are in the same file, simply because the IR is very straight forward. Because py-DJ uses a REPL interface, only one line is needed to be parsed at a time.

The first and perhaps most important component will be the parser. The parser defines `Rules` that represent differing effects expressions and interface expressions. Categorizing user expressions as `Rules` ended up working out quite nicely as the user could only input one type of expression at a time due to the nature of REPL. It parses individual expressions the user writes into one of these `Rules` object, which is the intermediate representation. These `Rules` objects are typical Python classes with unique constructors. Both the parser and intermediate representations are found in `parser.py`. The interpreter/semantics , found in `effects.py`, contain most of the audio effects. The final changes to the audio file are applied in the actual REPL interface, found in `repl.py`. In a sense, the REPL interface brings together the parser, the intermediate representation, and the interpreter/semantics.

## Evaluation
Provide some analysis of the work you did. In particular:

How "DSL-y" is your language? How close or far away is it from a general- purpose language?

What works well in your language? What are you particularly pleased with?

What could be improved? For example, how could the user's experience be better? How might your implementation be simpler or more cohesive? Are there more features you'd like to have? 

Does your current implementation differ from your larger vision for the language?

Re-visit your evaluation plan from the beginning of the project. Which tools have you used to evaluate the quality of your design? What have you learned from these evaluations? Have you made any significant changes as a result of these tools, the critiques, or user tests?

Where did you run into trouble and why? For example, did you come up with some syntax that you found difficult to implement, given your host language choice? Did you want to support multiple features, but you had trouble getting them to play well together?

