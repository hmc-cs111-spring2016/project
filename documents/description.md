# Project description

## Motivation
Many modern languages are not well designed for parallel computing (except ones like Chapel). You often have to separete parallel code from serial code via a for loop, a function call, or some other means. To further complicate things, you often need to call special functions, use strange syntax, and/or switch to certain compilers just to get off the ground. My goal is to create an easy-to-use library that allows you to make it easy to include implicitly parallel code right next to your standard serial code so that you can easily get parallel scpeedups without a lot of the mess that comes with traditional parallel languages or libraries. To do this, I plan on making a DSL that allows you to work with vectors like you would normal C++ variables. This will allow programmers to implicitly do operations on many variables with code that will look extraordinarily familiar.

## Language domain
This DSL will target vector-level parallelism. While it won't be best for every kind of parallel problem, it should work well for problems that involve doing largely the same operations to large sets of data and potentially reducing the results down to a single number (like doing dot products on vectors containing hundreds or thousands of variables).

There are other languages in this domain. Perhaps the most notable one being [Thrust](https://developer.nvidia.com/thrust). However, Thrust is only compatible with Nvidia GPUs and has really nasty syntax (you have to write GPU functions to do even fairly simple computations (which have a limited number of inputs) and even basic operations look terrible (negation is `thrust::negate<int>()`)).

## Language design
Like I said before, I would like my DSL to make working with many numbers as easy as working with individual ones. If `a` and `b` are variables in my DSL, then `a + b % 3` should be totally valid, regardless of whether `a` and `b` contain 1 value, 100 values, or many thousands of values. Reductions and other common vector operations should also be easy in my DSL. For instance, implementing a dot product should be as simple as `(a * b).sum()`. To make compatibility with serial code easier, it would be nice to support loading data to and from `std::vector`s, data structures that support iterators, and chunks of memory. However, I am still unsure if I can / will support control flow with my DSL (so `if (a == 1) {a = 2;}` may not be valid).

Potential errors could involve size mismatches (trying to add a variable containing 2 elements to one containing 4) and trying to use control flow if it is not supported. These kinds of errors might be able to be caught at compile time (where I might not have much control over what errors look like) and would definitely come up at run time (where it would be much easier to print out a relevant error message).

When a program runs, the DSL will automatically handle practically all the details of parallelism. For instance, it will decide between running the computations as a single-threaded vector instruction, multi-threaded vector operation, or a GPU kernel depending on the size of the data involved. It will also handle data movement so the user shouldn't have to know whether the data is stored in the GPU memory space or RAM. More advanced implementations could even use laziness to queue up operations and only execute them if they are needed (this could allow for performance improvements as the results of a previous operation can be reused immediately instead of stored away and loaded again from memory).

## Example computations
I have already given quite a few examples above as to the kinds of things the DSL should be able to do. In addition, I think it would be nice to support some of the features that `std::vector` and Thrust's vectors support. For example, being able to use `push_back` to add elements to the end of a vector, `pop_back` to remove them, and brackets to access arbitrary elements in the vector. Ideally, my implementation would be backwards compatible with `std::vector` so that users wouldn't have to switch between the two in their code and could just "upgrade" all their `std::vector`s to my vector implementation.
