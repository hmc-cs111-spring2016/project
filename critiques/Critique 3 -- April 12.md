## Response to Journal 

(Just as a note, I think that your project work should be in its own Github repo. Your current work lives inside your project repo. I don't remember the end file structure for the project off the top of my head, so this structure might be fine.)

First of all, it sounds like you were able to make a lot of good progress on your project this week. It was really helpful to see your demonstration in class because that gave me a practical indication of how someone could potentially use the language. It looked like you had a well-structured system, especially with specifically typed case classes. As someone with a computer science background, I think that the format of this DSL makes sense. I feel comfortable constructing an Attribute object and defining both the type and name of the attribute. 

You discussed comparators in the journal entry in the context of your filter method. It seems like the best solution to the problem is declaring entirely new comparators that take different types. With the case of `filter` which takes the `type A => Boolean` predicate, I'm sure you would get a lot of type errors if you're trying to parse to SQL. I think that you're going the right way by using Slick as a reference and using a similar implementation for the comparison operators. I believe that you had this working when you demonstated your project in class today. This did not seem like an overly complicated solution. In general, using Slick as a resource for complex problems is a good strategy to ensure that you don't get hung up on various parts of the problem and fail to finish the project. 

I really like what you've done for the `SQLType` object. From a software design perspective, I love how extensible you have made it. Your approach to the project has been to implement basic SQL functionality and then gradually build more complex operations into the program. This is really reflected in this typing system that can easily be expanded to support more types if necessary. Would you consider prompting the user of the language to edit the types contained within this object based on what their database supports? Better yet, if a user defines a schema for their SQL table, you could scan through the types defined in the schema and only include those in the `SQLType` object. 


## Response to Questions ##

With regards to defining a database schema, I don't see a vastly more efficient way than what you are currently doing. To the best of my understanding, you allow users to define their own classes which outline the database schema. I like that you combine the possible attributes into a list, making the number of arguments for a user-defined table more flexible than Slick. The only thing that feels a bit verbose to me is the declaration of each attribute. It is somewhat awkward to make the users declare each new attribute as a `FieldName` and assign types to them. However, I can't see a great solution to that unless you want to try and configure the `FieldName` type to be a `Field` that would take in a type and an attribute name. You could construct it like `new Field(Int, "id")` but this doesn't seem any more efficient and it seems like a lot of work for you. As far as this problem is concerned, I think that your current solution is fine and it is more valuable for you to work on implementing more features of SQL and collections in your project. 

You also asked about the limitation of defining a schema with tuples in Scala. Right off the bat, I can think of a hacky solution involving Scala tuples. You could try to store tuples in tuples, so if you have more than 22 fields, just store some of the fields in tuples. It would require more complex parsing code but would be a way to get past that constraint. Alternatively, it might be best to explore alternative ways of declaring database schema. For the purposes of this project, I think that you could get away with Slick's solution. Again, it seems like your time is best spent solving other problems. I don't forsee a case in the scope of your project where you would want to create a schema with more than 22 fields, but it is possible that a future user would want this functionality. 

I thought of a few things you could consider doing with your project as you move forward. Like we talked about in critique today, it's good to continue implementing the Scala collection methods. It's also worth testing whether the SQL queries that your program outputs will actually work in SQL. It shouldn't be too hard to set up a sample test table in mySQL and determine whether you can write a Scala query that will return valid data from the table. Currently, it seems like you've built the functionality of writing Scala to produce SQL queries, but it would be interesting if you were actually creating and querying the tables from Scala. That's a bit of a different direction and might get out of the project scope, but it's something to think about!
