# Language design and implementation overview

## Language design
Currently, a lot is up in the air as far as design goes because of a last-minute change from Scala to Python, which means I'm probably a step or two behind as far as design goes. However, the design choices that are not language-dependent are largely as they were before, so there aren't too many major design changes that aren't things like "use lists instead of Scala collections" and things like that.

Currently, the feel of the language is that the user writes programs in the language by typing in commands. However, my current setup is that the user interacts with the terminal through prompts such as "enter a file name" and "enter a rhyme scheme" (yet unwritten). This, I think, will eventually lend itself to use with a GUI or some other nice interface.

As of now, the basic computation performed by the language is the parsing, splitting, and checking of a text file against an API. The language heavily relies on Python lists, both for representation of results returned from the API, as well as in segmenting the poem into lines and words. I don't imagine needed too much beyond this, even once rhyme schemes come into the picture, as lists are sufficient for pretty much all the computation that's needed in the DSL.

There are no major control structures currently in the DSL outside of the case/switch which I intend to use to receive commands from the user. When a text file is read in, the last words of each line are sent to an API for rhyming comparisons, and then the rhymes are checked against the rhyme scheme. As such, the "order of operations" of the DSL currently is quite straightforward. The input to the language currently is a command (like "check poem") and a text file, and the output is usually some sort of response message from the DSL telling the user if their poem fits or if there are problems. I am considering possibly allowing the user to not need to use a text file.

There are a couple ways in which a program could go wrong. The first is if a word does not match anything in an API. The second is if words in the poem do not rhyme or match the rhyme scheme. In both cases, I intend for the DSL to provide helpful error code, such as "the poem did not match the rhyme scheme. These are the reasons:" or something like that. Error-checking, by extension, is a crucial part of the usefulness of the DSL. There is also the additional error that would occur if a user tries to input a command that doesn't exist; this would be handled by a simple "command not recognized. here are commands you can use: " type command.

One of my favorite things about this project is that there currently really isn't anything like it in the domain. To me, that's really exciting, though maybe there's a reason nothing exists... As such, there really isn't anything to compare it to. The one thing about the language that I don't currently love is that it really only allows for a very narrow subset of poetry, which is structured poetry with defined rhyme scheme. That said, there really isn't too much that can be done about that.

## Language implementation

For now, the plan is to do an external DSL in Python. I made this decision because of my target audience, which is middle school age students (who, more likely than not, have close to no experience with computer programming languages). Because my audience has probably very little experience, I wanted the language to feel as little like programming as possible. I know this is something of a futile effort, but having this in mind will hopefully make me continually mindful of making a project *for* my target audience.

After a substantial amount of time flailing about in Scala, I chose Python for a couple of reasons. For one, it was much, much easier to get my project off the ground. I wasted a disappointing amount of time this week trying to get a Scala project in order, and realized that it probably wasn't worth it to deal with all the added "fluff" of a Scala project. Additionally, though, I thought Python was a good choice because of how easy it is to interact with the terminal and receive inputs that way. Currently this is my desired way of communicating with the language, so Python was a good choice for that reason. It also doesn't hurt that Python has really good support in terms of built in libraries and things like that.

The big syntax design decision that I've made is that I want the DSL to function as a call and response between the user and the DSL. As such, it will work with the user inputting commands to a terminal, and using some sort of terminal prompt to ask the user to enter a text file name, or a rhyme scheme, or something like that, and have the terminal output the result. This is important for keeping the language "feel" out of the DSL and making it accessible to my audience. I haven't made any decisions about about the exact syntax i.e. word commands or anything like that, but I feel pretty set on my current overall syntax structure (if that even makes sense as a phrase).

The current architecture of my system is fuzzy and subject to changing tomorrow when I ask Prof. Ben / my critique group. Because of the switch to Python and the switch in how the user uses the DSL, I'm currently pretty fuzzy on my architecture and my IR (if I even have one). I currently have a number of files in a folder in my code project which import necessary functions from one another, but not only is the current system a total mess and not extensible, but it's been done without a huge amount of thought about architecture. This is primarily because I wanted to validate for myself that Python was the better language choice, and was determined to make a proof of concept that I was comfortable with. One of the big tasks for this week is to totally solidify the architecture.
